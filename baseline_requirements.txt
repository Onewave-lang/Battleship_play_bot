Собрать двухпользовательский «Морской бой» на python‑telegram‑bot v20+ с текстовым вводом ходов и выводом полей моноширинным <pre>. Я даю ниже: архитектуру, формат данных, логику состояний, ключевые алгоритмы (валидация координат, размещение кораблей с запретом соприкосновения, проверка «ранил/убил», автоконтур вокруг убитого), обработчики PTB, таймеры, шаблоны сообщений и советы по надёжности.

1) Архитектура и сценарий
1.1 Модель взаимодействия

Приватная дуэль по приглашению:

Игрок A → /newgame → бот создаёт match_id и высылает deep‑link: t.me/<bot>?start=inv_<match_id>.

Игрок B переходит по ссылке → присоединяется к матчу.

Идут две фазы: размещение → бой.

Весь ввод — текстом: для координат кораблей и выстрелов (кнопки не используем по ТЗ).

1.2 Рендеринг полей

Только текст, HTML parse_mode, вся доска в <pre>...</pre>.

Символы (простые, моноширинные):
· — пусто, x — мимо, ■ — попадание, ▓ — клетка убитого корабля, цифры/буквы — оси.

Визуальный отклик на выстрелы: сразу после хода промах помечаем красным крестиком, попадание — красным квадратом, а палубы уничтоженного корабля временно заменяем на символ 💣 и на следующем ходу возвращаем к стандартным обозначениям x/■/▓.

Рендерим два вида полей:

«Свое поле» (видны корабли и попадания врага).

«Поле соперника» (видны только ваши выстрелы: мимо/попадания/убитые).

2) Форматы и хранилище
2.1 Размеры и оси

Размер: 10 × 10.

Ось X (колонки, кириллица): а б в г д е ж з и к (10 букв, без «й»).

Ось Y (строки): 1…10.

Ввод клетки: пример г7, д10, допускаем пробелы и регистро‑/раскладочные варианты (см. 4.1).

2.2 Схема данных матча (JSON-представление)
{
  "match_id": "uuid",
  "status": "waiting|placing|playing|finished",
  "created_at": "2025-08-23T06:00:00Z",
  "players": {
    "A": {"user_id": 111, "chat_id": 111, "ready": false},
    "B": {"user_id": 222, "chat_id": 222, "ready": false}
  },
  "turn": "A|B",                 // чей ход в фазе боя
  "boards": {
    "A": { "ships": [...], "grid": [[0..],..], "alive_cells": 20 },
    "B": { "ships": [...], "grid": [[0..],..], "alive_cells": 20 }
  },
  "shots": {
    "A": {"history": ["г7","д3",...], "last_result": "miss|hit|kill"},
    "B": {"history": [...], "last_result": "..."}
  },
  "messages": {                   // (не обязательно, но удобно, если редактируете одно сообщение-«дашборд»)
    "A": {"main_msg_id": 0},
    "B": {"main_msg_id": 0}
  }
}

Поля boards.*

grid: целочисленная матрица 10×10. Рекомендуемые коды:

0 — пусто,

1 — живая палуба корабля,

2 — промах,

3 — попадание (ранен),

4 — убитая палуба,

5 — «запретная» вокруг убитого (точка, куда стрелять не надо).

ships: список кораблей:
{"cells":[[r,c],...], "alive":true} — палубы перечислены явным списком.

2.3 Флот

1×4, 2×3, 3×2, 4×1 = 10 кораблей, 20 палуб.

Вертикаль/горизонталь, минимум 1 клетка дистанции по всем восьми направлениям.

2.4 Хранилище

На старт: SQLite / TinyDB / JSON‑файл + file lock.

В проде: PostgreSQL (транзакции) или Redis (атомарные луа‑операции/блокировки).

Минимум CRUD:

create_match(a_user) → match_id.

join_match(match_id, b_user) → статус placing.

save_board(user, ships) → players.*.ready = true → когда оба ready → status=playing, turn='A'.

apply_shot(attacker, cell) → валидация → изменение grid, alive_cells → turn (повтор хода при hit/kill).

finish(winner).

3) Логика состояний (state machine)
waiting  --(B join)-->  placing  --(A ready & B ready)-->  playing  --(all sunk)--> finished


waiting: матч создан, ждёт второго игрока.

placing: оба по очереди (или параллельно) вводят свои корабли.

Рекомендуется предложить автогенерацию корректной расстановки (кнопкой или текстом «авто»).

playing:

Ходит текущий игрок; если miss → ход переходит, если hit/kill → ход остаётся.

При kill: автоматически помечаем контур вокруг корабля как «запретный» (код 5), и на поле соперника рисуем x в этих клетках.

finished: объявляем победителя, предлагаем «реванш» (создаёт новый match_id).

4) Ключевые алгоритмы
4.1 Парсинг координаты г7 / д10

Разрешаем:

кириллицу (а..к без й),

латиницу‑транслитерацию (опционально): a,b,v,g,d,e,zh,z,i,k.

Регекс для базового кириллического ввода:
^[абвгдежзик]\s*(10|[1-9])$ (регистр игнорируем, пробелы допускаем).

Маппинг букв→строка (0‑based):
{'а':0,'б':1,'в':2,'г':3,'д':4,'е':5,'ж':6,'з':7,'и':8,'к':9}
(при желании добавьте «й» как алиас к и, но не рекомендуется: в ТЗ букв 10).

Число→столбец: int(n)-1, проверка диапазона 0..9.

4.2 Проверка корректности размещения

Для каждого корабля:

Палубы в одну линию: либо все r одинаковы, либо все c одинаковы.

Длина совпадает с типом корабля.

Клетки в пределах 0..9.

Нет касаний с уже поставленными кораблями: проверяем все 8 соседей каждой новой палубы плюс саму палубу — на отсутствие 1 в grid.

Автогенерация расстановки (рекомендовано)

Пытаемся случайно ставить каждый корабль, пока не найдём валидную позицию (ограничивайте число попыток, 1000 хватит).

Сразу помечаем grid[r][c]=1 для палуб.

4.3 Применение выстрела

В матрице обороняющегося:

Если 0 → 2 (miss).

Если 1 → 3 (hit) и проверка «убит ли корабль?».

Находим корабль (либо через индекс в ships, либо пробегом по списку и совпадением клетки).

Если все палубы корабля теперь в состоянии 3 или 4 → это kill:

Переводим все его палубы 3→4.

Обводим контур: все 8‑соседи каждой палубы:

Если клетка в пределах и не 4, ставим 5 (запретная/мимо для пола соперника).

Возвращаем miss|hit|kill.

Счётчик alive_cells уменьшаем только при первом попадании по палубе (из 1 в 3).

4.4 «Право дополнительного хода»

Если hit|kill → тот же атакующий ходит снова.

Если miss → ход переходит.

4.5 Условия окончания

Если defender.alive_cells == 0 → победа атакующего, status=finished.

5) Вывод поля (рендер)
5.1 Легенда символов

На своём поле: показываем корабли:

1 → ■ (или #, если хотите только ASCII),

2 → x,

3 → ■ (попадание, можно оставить тем же символом или, например, *),

4 → ▓,

5 → · (пусто/запретная — игроку без разницы).

На поле соперника (видимое атакующему):

Ничего не показываем про неоткрытые клетки: ·.

2 → x,

3 → ■,

4 → ▓,

5 → x (так игрок видит, что туда стрелять не нужно).

5.2 Пример вывода (HTML)

Отправляйте в Telegram с parse_mode='HTML':

<pre>    а б в г д е ж з и к
1  | · · · · · · · · · ·
2  | · · · · · · · · · ·
3  | · · · · · · · · · ·
4  | · · · · · · · · · ·
5  | · · · · · · · · · ·
6  | · · · · · · · · · ·
7  | · · · · · · · · · ·
8  | · · · · · · · · · ·
9  | · · · · · · · · · ·
10 | · · · · · · · · · ·</pre>


Важно: экранируйте &, <, > в обычном тексте вне <pre>, внутри <pre> — содержите только символы доски.

6) UX‑потоки и тексты
6.1 /newgame (А создаёт матч)

Ответ А:

«Матч создан. Пригласите соперника: t.me/<bot>?start=inv_<match_id>».

«Далее — фаза размещения. Вышлите авто для автогенерации, или список кораблей в формате:
4: а1-а4; 3: г7-е7; 3: и10-к10; 2: ...; 2: ...; 2: ...; 1: ...; 1: ...; 1: ...; 1: ...
Используйте горизонтальные/вертикальные отрезки.»

6.2 start inv_<id> (B присоединяется)

Ответ B:

«Вы подключены к матчу с <@A>. Разместите флот: авто или вручную (см. формат выше).»

Ответ А:

«Игрок B подключился. Разместите флот: авто или вручную.»

6.3 Подтверждение размещения

После валидной расстановки: «Флот принят ✅. Ожидаем соперника.»

Когда оба готовы: «Игра началась! Первыми ходят: A/B.»

Выводим оба поля каждому игроку: своё и «поле соперника».

6.4 Ходы

Подсказка: «Ваш ход. Введите клетку, например: д10».

На каждый ход возвращаем короткий фидбек: Мимо, Ранил, Убил + обновлённые поля.

При таймауте хода (если используете): «Время вышло, ход переходит сопернику.»

6.5 Завершение

«Победа <@user>! Все корабли соперника уничтожены.»

Кнопка/фраза «реванш» → создаём новый матч тем же составом.

7) PTB v20: обработчики
7.1 Каркас (Polling/Webhook — на ваше усмотрение)

Application.builder().token(TOKEN).build()

Handlers:

CommandHandler("newgame", newgame)

CommandHandler("start", start) — ловим inv_<id>

MessageHandler(filters.TEXT & ~filters.COMMAND, router_text) — общий роутер текстовых входов по текущему status/подфазе пользователя.

Дополнительно: /cancel, /help.

7.2 Управление состоянием пользователя

В таблице «users» держите current_match_id, phase: placing|playing|idle и «ожидаемое действие»:

awaiting_fleet — ждём ввод флота/авто.

awaiting_shot — ждём выстрел.

router_text(update):

Ищем пользователя → его current_match_id → матч.

Если placing и awaiting_fleet: обрабатываем авто/ввод; если ОК → ready=true, проверяем второго.

Если playing и это его очередь: парсим координату, применяем выстрел, рендерим, уведомляем обоих, обновляем turn/победителя.

7.3 Таймеры (необязательно, но полезно)

application.job_queue.run_once(timeout_job, when=turn_deadline, data=match_id)

В timeout_job: если ход не сделан — фиксируем miss/переход хода.

8) Формат ввода флота вручную

Простой вариант: отрезки (буквально 10 штук):

4: а1-а4

3: г7-е7

…
Правила парсинга:

Сплит по «;».

Для каждого — длина + два конца отрезка (start_cell, end_cell).

Нормализуем так, чтобы start<=end.

Вычисляем список клеток отрезка (по r или по c).

Проверяем длину, границы, отсутствие касаний/пересечений.

В случае ошибок — вернуть список проблем с подсветкой.

Альтернатива: «посекционный» ввод (сначала все «4», потом «3», …), но это дольше.

9) Рендерер доски

Функция render_board_own(board) возвращает строку <pre>...</pre>.

Функция render_board_enemy(enemy_board) — преобразует коды 2/3/4/5 в x/■/▓/x, остальное — ·.

Общий заголовок: ось X — кириллица (абвгдежзик); ось Y — числа 1…10.

Следите, чтобы ширина строки укладывалась (~30–35 символов). Используйте одиночные пробелы.

10) Античит и валидация

Любое действие сверяйте с матчем:

Пользователь действительно участник?

Сейчас его очередь (в фазе боя)?

Клетка ранее не стреляна?

В фазе placing — еще нет ready.

На каждое текстовое событие отвечайте чётким описанием, при ошибке — сообщением, что именно не так.

Дедуп кликов не нужен (кнопок нет), но повторы текста могут быть — фильтруйте «двойные» ходы с одинаковым turn_counter.

11) Тонкости «убил» (контур)

После признания корабля «убитым»:

Все его палубы → 4.

Все соседние клетки (8 направлений от каждой палубы), если в пределах:

Если там 0 → 5 (запретная, эквивалент «мимо» для отображения на поле соперника как x).

Если уже 2/3/4/5 — оставьте как есть.

Это улучшает UX: игрок видит «зачёркнутую» зону вокруг убитого.

12) Сообщения‑шаблоны (совмещаем поля и статус)

После каждого значимого шага шлите короткую сводку + две доски:

Игроку A:

«Ваше поле:»

<pre>...own A...</pre>

«Поле соперника:»

<pre>...enemy B...</pre>

«Результат хода: Ранил / Убил / Мимо»

«Теперь ходит: Вы / Соперник»

Игроку B — симметрично.

13) Мини‑скелет модулей (рекомендация по структуре)
project/
  app.py                   # точка входа PTB
  storage.py               # CRUD матчей/юзеров
  models.py                # датаклассы (Match, Board, Ship)
  logic/
    parser.py              # парсинг координат/отрезков
    placement.py           # валидация/автоген кораблей
    battle.py              # выстрел, hit/kill/контур, победа
    render.py              # рендер <pre> досок
  handlers/
    commands.py            # /start /newgame /help
    router.py              # текстовый роутер состояний
    jobs.py                # таймеры (если нужны)

14) Тест‑чеклист

Парсер координат: д10, г7, пробелы, регистр, недопустимые буквы/числа.

Размещение: все типы кораблей; запрет касаний; граничные клетки; ручной и авто.

Ходы: мимо → смена хода; ранил/убил → повторный ход; несколько попаданий подряд; автоконтур.

Окончание: последнее попадание закрывает матч; реванш создаёт новый.

Стабильность: параллельные сообщения, быстрые «двойные» ходы, возврат после падения процесса (персистентность).

Рендер: ширина на телефоне, корректные символы, отсутствие emoji, parse_mode=HTML.

15) Частые ошибки и как их избежать

Случайные переносы строк в поле → проверяйте, что строка короче ~35 символов.

Смешение раскладок → нормализуйте ввод (приведение к нижнему регистру, удаление пробелов, маппинг латиницы→кириллица при желании).

Гонки состояний → сначала атомарно примените действие к БД, потом шлите обновления обоим.

Утечка приватной информации → на «поле соперника» никогда не рендерьте живые палубы.

16) Подсказки по реализации в PTB (v20+)

MessageHandler(filters.TEXT & ~filters.COMMAND, router_text) — единая точка для «авто», расстановки и выстрелов.

Для deep‑link: в start(update, context) смотрите update.message.text → split() → ищите inv_<id>.

Чтобы «держать ход»: поле turn ('A'|'B') + last_result.

В ответах используйте две отправки (каждому в личный чат) или редактируйте сохранённое «главное сообщение» (если так решили).

17) Пример формата ошибок (дружелюбный)

«Не понял клетку. Пример: е5 или д10. Допускаются пробелы и регистр неважен.»

«Размещение некорректно: корабль 3 палубы г7-е7 — диагональ запрещена. Используйте г7-г9 или е5-г5.»

18) Что можно упростить на старте

Только автогенерация флота: убирает целый пласт парсинга отрезков.

Без таймеров: добавите позже.


19) Режим «Тест 2 игроков»

Доступность: кнопку запуска теста видит только ADMIN_ID, остальные пользователи её не получают ни в одном сценарии.

Сценарий: по нажатию кнопки создаётся новый матч, где администратор занимает роль игрока A, а роль игрока B берет на себя встроенный тестовый бот. Процесс должен имитировать полноценную приватную дуэль без шага приглашения: после создания матча запускаются те же стадии размещения и боя, что и в стандартном сценарии. Все сообщения, шаблоны, уведомления о ходе, результатах выстрелов и завершении матча остаются идентичными обычной игре, чтобы можно было проверить весь пользовательский флоу «как есть».

Поведение тестового бота: он сразу расставляет корабли (можно автогенерацией из основного алгоритма), стреляет по случайным незанятым клеткам и сохраняет ту же бизнес-логику обработки попаданий/убийств, что и для живых игроков. Между действиями бота добавьте небольшую искусственную задержку (1–2 секунды), чтобы переписка выглядела естественно и не ломала порядок сообщений.