from __future__ import annotations
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import ContextTypes
import asyncio

import storage
from logic.parser import parse_coord, ROWS
from logic.placement import random_board
from logic.battle import apply_shot, MISS, HIT, KILL, REPEAT
from logic.render import render_board_own, render_board_enemy


async def _send_state(
    context: ContextTypes.DEFAULT_TYPE,
    match,
    player_key: str,
    message: str,
    *,
    blink_cells=None,
    blink_on="enemy",
    show_dot=False,
    blink_red=False,
    message_id=None,
):
    """Send current boards and message to the given player."""
    enemy_key = "B" if player_key == "A" else "A"
    if blink_on == "own" and blink_cells is not None:
        own = render_board_own(
            match.boards[player_key], blink_cells, show_dot, blink_red
        )
    else:
        own = render_board_own(match.boards[player_key])
    if blink_on == "enemy" and blink_cells is not None:
        enemy = render_board_enemy(
            match.boards[enemy_key], blink_cells, show_dot, blink_red
        )
    else:
        enemy = render_board_enemy(match.boards[enemy_key])
    text = f"–í–∞—à–µ –ø–æ–ª–µ:\n{own}\n–ü–æ–ª–µ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞:\n{enemy}\n{message}"
    if message_id:
        await context.bot.edit_message_text(
            text,
            match.players[player_key].chat_id,
            message_id,
            parse_mode="HTML",
        )
        return None
    return await context.bot.send_message(
        match.players[player_key].chat_id, text, parse_mode="HTML"
    )


async def _animate_shot(
    context: ContextTypes.DEFAULT_TYPE,
    match,
    shooter_key: str,
    defender_key: str,
    result_self: str,
    result_enemy: str,
    cells,
    *,
    red=False,
):
    blink = set(cells)
    msg_self = await _send_state(
        context,
        match,
        shooter_key,
        result_self,
        blink_cells=blink,
        blink_on="enemy",
        blink_red=red,
    )
    msg_enemy = await _send_state(
        context,
        match,
        defender_key,
        result_enemy,
        blink_cells=blink,
        blink_on="own",
        blink_red=red,
    )
    show_dot = False
    for _ in range(8):
        await asyncio.sleep(0.5)
        show_dot = not show_dot
        await _send_state(
            context,
            match,
            shooter_key,
            result_self,
            blink_cells=blink,
            blink_on="enemy",
            show_dot=show_dot,
            blink_red=red,
            message_id=msg_self.message_id,
        )
        await _send_state(
            context,
            match,
            defender_key,
            result_enemy,
            blink_cells=blink,
            blink_on="own",
            show_dot=show_dot,
            blink_red=red,
            message_id=msg_enemy.message_id,
        )
    await _send_state(
        context,
        match,
        shooter_key,
        result_self,
        blink_cells=blink,
        blink_on="enemy",
        show_dot=False,
        blink_red=False,
        message_id=msg_self.message_id,
    )
    await _send_state(
        context,
        match,
        defender_key,
        result_enemy,
        blink_cells=blink,
        blink_on="own",
        show_dot=False,
        blink_red=False,
        message_id=msg_enemy.message_id,
    )


async def router_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    text = update.message.text.strip().lower()
    match = storage.find_match_by_user(user_id)
    if not match:
        await update.message.reply_text('–í—ã –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ –≤ –º–∞—Ç—á–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /newgame.')
        return

    player_key = 'A' if match.players['A'].user_id == user_id else 'B'
    enemy_key = 'B' if player_key == 'A' else 'A'

    if match.status == 'placing':
        if text == '–∞–≤—Ç–æ':
            board = random_board()
            storage.save_board(match, player_key, board)
            if match.status == 'playing':
                await _send_state(
                    context,
                    match,
                    player_key,
                    '–ö–æ—Ä–∞–±–ª–∏ —Ä–∞—Å—Å—Ç–∞–≤–ª–µ–Ω—ã. –ë–æ–π –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è! '
                    + ('–í–∞—à —Ö–æ–¥.' if match.turn == player_key else '–•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.'),
                )
                await _send_state(
                    context,
                    match,
                    enemy_key,
                    '–°–æ–ø–µ—Ä–Ω–∏–∫ –≥–æ—Ç–æ–≤. –ë–æ–π –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è! '
                    + ('–í–∞—à —Ö–æ–¥.' if match.turn == enemy_key else '–•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.'),
                )
            else:
                await _send_state(
                    context,
                    match,
                    player_key,
                    '–ö–æ—Ä–∞–±–ª–∏ —Ä–∞—Å—Å—Ç–∞–≤–ª–µ–Ω—ã. –û–∂–∏–¥–∞–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.',
                )
                await _send_state(
                    context,
                    match,
                    enemy_key,
                    '–°–æ–ø–µ—Ä–Ω–∏–∫ –≥–æ—Ç–æ–≤. –û—Ç–ø—Ä–∞–≤—å—Ç–µ "–∞–≤—Ç–æ" –¥–ª—è —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ –∫–æ—Ä–∞–±–ª–µ–π.',
                )
        else:
            await update.message.reply_text('–í–≤–µ–¥–∏—Ç–µ "–∞–≤—Ç–æ" –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏.')
        return

    if match.status != 'playing':
        if match.status == 'waiting':
            await update.message.reply_text('–ú–∞—Ç—á –µ—â—ë –Ω–µ –Ω–∞—á–∞–ª—Å—è. –û–∂–∏–¥–∞–µ–º —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.')
        else:
            await update.message.reply_text('–ú–∞—Ç—á –µ—â—ë –Ω–µ –Ω–∞—á–∞–ª—Å—è.')
        return

    if match.turn != player_key:
        await _send_state(context, match, player_key, '–°–µ–π—á–∞—Å —Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.')
        return

    coord = parse_coord(text)
    if coord is None:
        await _send_state(context, match, player_key, '–ù–µ –ø–æ–Ω—è–ª –∫–ª–µ—Ç–∫—É. –ü—Ä–∏–º–µ—Ä: –µ5 –∏–ª–∏ –¥10.')
        return

    r, c = coord
    coord_str = f"{ROWS[r]}{c+1}"
    result = apply_shot(match.boards[enemy_key], coord)
    match.shots[player_key]['history'].append(text)
    match.shots[player_key]['last_result'] = result
    error = None

    if result == MISS:
        match.turn = enemy_key
        result_self = f'{coord_str}: –ú–∏–º–æ. –•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.'
        result_enemy = f'{coord_str}: –°–æ–ø–µ—Ä–Ω–∏–∫ –ø—Ä–æ–º–∞—Ö–Ω—É–ª—Å—è. –í–∞—à —Ö–æ–¥.'
        error = storage.save_match(match)
    elif result == HIT:
        result_self = f'{coord_str}: –†–∞–Ω–∏–ª. –í–∞—à —Ö–æ–¥.'
        result_enemy = f'{coord_str}: –°–æ–ø–µ—Ä–Ω–∏–∫ —Ä–∞–Ω–∏–ª –≤–∞—à –∫–æ—Ä–∞–±–ª—å. –•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.'
        error = storage.save_match(match)
    elif result == REPEAT:
        result_self = f'{coord_str}: –ö–ª–µ—Ç–∫–∞ —É–∂–µ –æ–±—Å—Ç—Ä–µ–ª—è–Ω–∞. –í–∞—à —Ö–æ–¥.'
        result_enemy = f'{coord_str}: –°–æ–ø–µ—Ä–Ω–∏–∫ —Å—Ç—Ä–µ–ª—è–ª –ø–æ —É–∂–µ –æ–±—Å—Ç—Ä–µ–ª—è–Ω–Ω–æ–π –∫–ª–µ—Ç–∫–µ. –•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.'
        error = storage.save_match(match)
    else:
        if match.boards[enemy_key].alive_cells == 0:
            error = storage.finish(match, player_key)
            result_self = f'{coord_str}: –ö–æ—Ä–∞–±–ª—å —É–Ω–∏—á—Ç–æ–∂–µ–Ω! –í—ã –ø–æ–±–µ–¥–∏–ª–∏.'
            result_enemy = f'{coord_str}: –í—Å–µ –≤–∞—à–∏ –∫–æ—Ä–∞–±–ª–∏ –ø–æ—Ç–æ–ø–ª–µ–Ω—ã.'
        else:
            result_self = f'{coord_str}: –ö–æ—Ä–∞–±–ª—å —É–Ω–∏—á—Ç–æ–∂–µ–Ω! –í–∞—à —Ö–æ–¥.'
            result_enemy = f'{coord_str}: –°–æ–ø–µ—Ä–Ω–∏–∫ —É–Ω–∏—á—Ç–æ–∂–∏–ª –≤–∞—à –∫–æ—Ä–∞–±–ª—å. –•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞.'
            error = storage.save_match(match)

    if error:
        msg = '–ü—Ä–æ–∏–∑–æ—à–ª–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞. –•–æ–¥ –ø—Ä–µ—Ä–≤–∞–Ω.'
        await context.bot.send_message(match.players[player_key].chat_id, msg)
        await context.bot.send_message(match.players[enemy_key].chat_id, msg)
        return

    cells = [coord]
    if result == KILL:
        for ship in match.boards[enemy_key].ships:
            if not ship.alive and coord in ship.cells:
                cells = ship.cells
                break

    if result == REPEAT:
        await _send_state(context, match, player_key, result_self)
        await _send_state(context, match, enemy_key, result_enemy)
    else:
        await _animate_shot(
            context,
            match,
            player_key,
            enemy_key,
            result_self,
            result_enemy,
            cells,
            red=result in (HIT, KILL),
        )

    if match.status == 'finished':
        kb = ReplyKeyboardMarkup([['/newgame']], one_time_keyboard=True)
        await context.bot.send_message(
            match.players[player_key].chat_id,
            'üéâ –ü–æ–±–µ–¥–∞! –í—ã —Ä–∞–∑–≥—Ä–æ–º–∏–ª–∏ —Ñ–ª–æ—Ç —Å–æ–ø–µ—Ä–Ω–∏–∫–∞!',
        )
        await context.bot.send_message(
            match.players[enemy_key].chat_id,
            '‚öì –°–æ–ø–µ—Ä–Ω–∏–∫ –æ–¥–µ—Ä–∂–∞–ª –ø–æ–±–µ–¥—É. –ù–µ —Å–¥–∞–≤–∞–π—Ç–µ—Å—å, —É–¥–∞—á–∞ —É–ª—ã–±–Ω—ë—Ç—Å—è –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑.',
        )
        for key in (player_key, enemy_key):
            await context.bot.send_message(
                match.players[key].chat_id,
                '–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!',
                reply_markup=kb,
            )
